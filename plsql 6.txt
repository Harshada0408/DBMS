plsql 6






6. Database Trigger (All Types: Row level and Statement level triggers, Before and After Triggers).

Code:
-- 1Ô∏è‚É£ Drop Tables if Exist
DROP TABLE IF EXISTS Library_Audit;
DROP TABLE IF EXISTS Library;


-- 2Ô∏è‚É£ Create Library Table
CREATE TABLE Library (
    book_id SERIAL PRIMARY KEY,
    book_name VARCHAR(100),
    author VARCHAR(50),
    issued_to INT,
    status CHAR(1) DEFAULT 'I'  -- I = Issued, R = Returned
);


-- 3Ô∏è‚É£ Create Audit Table
CREATE TABLE Library_Audit (
    audit_id SERIAL PRIMARY KEY,
    book_id INT,
    book_name VARCHAR(100),
    author VARCHAR(50),
    issued_to INT,
    status CHAR(1),
    action_type VARCHAR(10),      -- 'INSERT', 'UPDATE', 'DELETE'
    action_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


-- 4Ô∏è‚É£ Create Trigger Function
CREATE OR REPLACE FUNCTION library_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO Library_Audit(book_id, book_name, author, issued_to, status, action_type)
        VALUES (NEW.book_id, NEW.book_name, NEW.author, NEW.issued_to, NEW.status, 'INSERT');
        RETURN NEW;


    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO Library_Audit(book_id, book_name, author, issued_to, status, action_type)
        VALUES (OLD.book_id, OLD.book_name, OLD.author, OLD.issued_to, OLD.status, 'UPDATE');
        RETURN NEW;


    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO Library_Audit(book_id, book_name, author, issued_to, status, action_type)
        VALUES (OLD.book_id, OLD.book_name, OLD.author, OLD.issued_to, OLD.status, 'DELETE');
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;


-- 5Ô∏è‚É£ Create Triggers on Library Table


-- BEFORE INSERT Trigger (Row-Level)
CREATE TRIGGER trg_library_insert
AFTER INSERT ON Library
FOR EACH ROW
EXECUTE FUNCTION library_audit_trigger();


-- BEFORE UPDATE Trigger (Row-Level)
CREATE TRIGGER trg_library_update
BEFORE UPDATE ON Library
FOR EACH ROW
EXECUTE FUNCTION library_audit_trigger();


-- BEFORE DELETE Trigger (Row-Level)
CREATE TRIGGER trg_library_delete
BEFORE DELETE ON Library
FOR EACH ROW
EXECUTE FUNCTION library_audit_trigger();


-- 6Ô∏è‚É£ Insert Sample Data
INSERT INTO Library(book_name, author, issued_to, status) VALUES
('Database Systems', 'Alice', 101, 'I'),
('Algorithms', 'Bob', 102, 'I'),
('Operating Systems', 'Charlie', 103, 'I');


-- 7Ô∏è‚É£ Test Triggers


-- Update a Book
UPDATE Library
SET status = 'R', issued_to = NULL
WHERE book_id = 1;


-- Delete a Book
DELETE FROM Library
WHERE book_id = 2;


-- Insert a New Book
INSERT INTO Library(book_name, author, issued_to, status)
VALUES ('Data Science', 'David', 104, 'I');


-- 8Ô∏è‚É£ Verify Audit Table
SELECT * FROM Library_Audit;


-- 9Ô∏è‚É£ Verify Library Table
SELECT * FROM Library;





plsql6



-- üßπ Step 1: Drop tables if they exist
DROP TABLE IF EXISTS n_rollcall;
DROP TABLE IF EXISTS o_rollcall;

-- üèó Step 2: Create tables
CREATE TABLE n_rollcall (
    roll INT PRIMARY KEY,
    name VARCHAR(20),
    class VARCHAR(10)
);

CREATE TABLE o_rollcall (
    roll INT PRIMARY KEY,
    name VARCHAR(20),
    class VARCHAR(10)
);

-- üßæ Step 3: Insert sample data
INSERT INTO n_rollcall VALUES 
(1, 'Arushi', 'SE'),
(2, 'Pranali', 'SE');

INSERT INTO o_rollcall VALUES 
(2, 'Pranali', 'SE'),
(3, 'Harshada', 'TE'),
(4, 'Aditi', 'BE');

-- ‚öô Step 4: Create procedure using explicit cursor
CREATE OR REPLACE PROCEDURE merge_roll_data()
LANGUAGE plpgsql
AS $$
DECLARE
    v_roll INT;
    v_name VARCHAR(20);
    v_class VARCHAR(10);
    v_count INT;

    -- Explicit cursor to iterate through old rollcall table
    c1 CURSOR FOR SELECT roll, name, class FROM o_rollcall;
BEGIN
    OPEN c1;
    LOOP
        FETCH c1 INTO v_roll, v_name, v_class;
        EXIT WHEN NOT FOUND;

        -- Check if this roll already exists in new_rollcall
        SELECT COUNT(*) INTO v_count FROM n_rollcall WHERE roll = v_roll;

        IF v_count = 0 THEN
            INSERT INTO n_rollcall (roll, name, class) VALUES (v_roll, v_name, v_class);
            RAISE NOTICE '‚úÖ Inserted: Roll=% | Name=% | Class=%', v_roll, v_name, v_class;
        ELSE
            RAISE NOTICE '‚è© Skipped duplicate: Roll=% already exists', v_roll;
        END IF;
    END LOOP;

    CLOSE c1;
    RAISE NOTICE 'üéØ Merge Completed Successfully!';
END;
$$;

-- ‚ñ∂ Step 5: Execute the procedure
CALL merge_roll_data();

-- üìä Step 6: Verify data
SELECT * FROM n_rollcall ORDER BY roll;











create or replace procedure merge_rollcalls()
language plpgsql
as $$
declare
	merge_cur refcursor;
	rec record;
	r record;
	v_exists int;
begin
	for r in select * from N_RollCall loop
		select count(*) into v_exists from O_RollCall where roll_no= r.roll_no;
		if v_exists= 0 then
			open merge_cur for select * from N_RollCall where roll_no= r.roll_no;
			fetch merge_cur into rec;
			insert into O_RollCall values (rec.roll_no, rec.name);
			raise notice 'inserted roll no: %, name: %', rec.roll_no, rec.name;
			close merge_cur;
		else
			raise notice 'skipped (already exists) roll no: %, name: %', r.roll_no, r.name; 
		end if;
	end loop;
exception
	when others then 
		raise notice 'unexpected error!';
end;
$$;
call merge_rollcalls();