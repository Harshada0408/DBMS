dbsm claude


# plsql6_final

```sql
-- 1Ô∏è‚É£ Drop tables if they exist
DROP TABLE IF EXISTS O_RollCall CASCADE;
DROP TABLE IF EXISTS N_RollCall CASCADE;

-- 2Ô∏è‚É£ Create tables
CREATE TABLE O_RollCall (
    roll_no INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE N_RollCall (
    roll_no INT PRIMARY KEY,
    name VARCHAR(50)
);

-- 3Ô∏è‚É£ Insert sample data
INSERT INTO O_RollCall (roll_no, name) VALUES
(101, 'Alice'),
(102, 'Bob');

INSERT INTO N_RollCall (roll_no, name) VALUES
(102, 'Bob'),
(103, 'Charlie'),
(104, 'David');

-- 4Ô∏è‚É£ Create procedure using parameterized cursor
CREATE OR REPLACE PROCEDURE merge_rollcalls()
LANGUAGE plpgsql
AS $$
DECLARE
    r_row RECORD;           -- record variable to loop through N_RollCall
    r_rec RECORD;           -- record variable to fetch cursor data
    c_merge CURSOR(p_roll_no INT) FOR
        SELECT roll_no, name
        FROM N_RollCall
        WHERE roll_no = p_roll_no;
BEGIN
    -- Loop through all rows of N_RollCall
    FOR r_row IN SELECT roll_no FROM N_RollCall LOOP
        OPEN c_merge(r_row.roll_no);        -- pass parameter
        FETCH c_merge INTO r_rec;

        -- Insert only if not already in O_RollCall
        IF NOT EXISTS (SELECT 1 FROM O_RollCall WHERE roll_no = r_rec.roll_no) THEN
            INSERT INTO O_RollCall (roll_no, name)
            VALUES (r_rec.roll_no, r_rec.name);
            RAISE NOTICE 'Inserted: Roll_no=% | Name=%', r_rec.roll_no, r_rec.name;
        ELSE
            RAISE NOTICE 'Skipped duplicate: Roll_no=% | Name=%', r_rec.roll_no, r_rec.name;
        END IF;

        CLOSE c_merge;
    END LOOP;

    RAISE NOTICE 'üéØ Merge Completed Successfully!';
END;
$$;

-- 5Ô∏è‚É£ Call the procedure
CALL merge_rollcalls();

-- 6Ô∏è‚É£ Verify the merged table
SELECT * FROM O_RollCall ORDER BY roll_no;
```











# plsql6correct

5. Cursors: (All types: Implicit, Explicit, Cursor FOR Loop, Parameterized Cursor).

```sql
-- 1Ô∏è‚É£ Drop tables if they exist
DROP TABLE IF EXISTS O_RollCall;
DROP TABLE IF EXISTS N_RollCall;


-- 2Ô∏è‚É£ Create tables
CREATE TABLE O_RollCall (
    roll_no INT PRIMARY KEY,
    name VARCHAR(50)
);


CREATE TABLE N_RollCall (
    roll_no INT PRIMARY KEY,
    name VARCHAR(50)
);


-- 3Ô∏è‚É£ Insert sample data
INSERT INTO O_RollCall (roll_no, name) VALUES
(101, 'Alice'),
(102, 'Bob');


INSERT INTO N_RollCall (roll_no, name) VALUES
(102, 'Bob'),
(103, 'Charlie'),
(104, 'David');


-- 4Ô∏è‚É£ Merge using a "parameterized-like" cursor
DO
$$
DECLARE
    v_min_roll_no INT := 0;  -- parameter for the cursor simulation
    r_rec RECORD;
    cur_n_rollcall REFCURSOR;  -- explicit cursor
BEGIN
    -- Open cursor with a parameter
    OPEN cur_n_rollcall FOR
        SELECT roll_no, name
        FROM N_RollCall
        WHERE roll_no >= v_min_roll_no;


    LOOP
        FETCH cur_n_rollcall INTO r_rec;
        EXIT WHEN NOT FOUND;


        -- Insert into O_RollCall if not exists
        IF NOT EXISTS (SELECT 1 FROM O_RollCall WHERE roll_no = r_rec.roll_no) THEN
            INSERT INTO O_RollCall (roll_no, name)
            VALUES (r_rec.roll_no, r_rec.name);
        END IF;
    END LOOP;


    CLOSE cur_n_rollcall;


    RAISE NOTICE 'Merge Completed Successfully!';
END;
$$;


-- 5Ô∏è‚É£ Verify merged table
SELECT * FROM O_RollCall;
```











# correct plsql7

```sql
-- =========================================================
-- üß© DROP OLD TABLES IF THEY EXIST
-- =========================================================
DROP TABLE IF EXISTS library_audit;
DROP TABLE IF EXISTS library;

-- =========================================================
-- üõ† CREATE MAIN TABLE: library
-- =========================================================
CREATE TABLE library (
    bno INT PRIMARY KEY,
    bname VARCHAR(40),
    author VARCHAR(20),
    allowed_days INT
);

-- =========================================================
-- üóÉ CREATE AUDIT TABLE: library_audit
-- =========================================================
CREATE TABLE library_audit (
    audit_id SERIAL PRIMARY KEY,
    bno INT,
    old_allowed_days INT,
    new_allowed_days INT,
    action VARCHAR(10),
    action_time TIMESTAMP DEFAULT NOW()
);

-- =========================================================
-- üìö INSERT SAMPLE DATA
-- =========================================================
INSERT INTO library VALUES 
(1, 'Database Systems', 'Tom', 10),
(2, 'System Programming', 'John', 20),
(3, 'Computer Networks', 'Sara', 18),
(4, 'Agile Project Management', 'Ken', 24),
(5, 'Python for Data Analysis', 'Wes', 12);

-- =========================================================
-- üîπ 1Ô∏è‚É£ ROW-LEVEL BEFORE TRIGGER
-- Runs before each row is updated or deleted
-- Used for validation or logging before actual change
-- =========================================================
CREATE OR REPLACE FUNCTION before_row_func()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        RAISE NOTICE 'BEFORE UPDATE (Row-Level): Book % changing allowed_days from % to %',
            OLD.bno, OLD.allowed_days, NEW.allowed_days;
    ELSIF TG_OP = 'DELETE' THEN
        RAISE NOTICE 'BEFORE DELETE (Row-Level): Book % with allowed_days % will be deleted',
            OLD.bno, OLD.allowed_days;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_row_trigger
BEFORE UPDATE OR DELETE ON library
FOR EACH ROW
EXECUTE FUNCTION before_row_func();

-- =========================================================
-- üîπ 2Ô∏è‚É£ ROW-LEVEL AFTER TRIGGER
-- Runs after each row is updated or deleted
-- Used for auditing old and new values
-- =========================================================
CREATE OR REPLACE FUNCTION after_row_func()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO library_audit (bno, old_allowed_days, new_allowed_days, action)
        VALUES (OLD.bno, OLD.allowed_days, NEW.allowed_days, 'UPDATE');
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO library_audit (bno, old_allowed_days, new_allowed_days, action)
        VALUES (OLD.bno, OLD.allowed_days, NULL, 'DELETE');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_row_trigger
AFTER UPDATE OR DELETE ON library
FOR EACH ROW
EXECUTE FUNCTION after_row_func();

-- =========================================================
-- üîπ 3Ô∏è‚É£ STATEMENT-LEVEL BEFORE TRIGGER
-- Runs once before the UPDATE or DELETE statement starts
-- =========================================================
CREATE OR REPLACE FUNCTION before_stmt_func()
RETURNS TRIGGER AS $$
BEGIN
    RAISE NOTICE 'BEFORE STATEMENT (Statement-Level) Trigger Fired for operation: %', TG_OP;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_stmt_trigger
BEFORE UPDATE OR DELETE ON library
FOR EACH STATEMENT
EXECUTE FUNCTION before_stmt_func();

-- =========================================================
-- üîπ 4Ô∏è‚É£ STATEMENT-LEVEL AFTER TRIGGER
-- Runs once after the UPDATE or DELETE statement completes
-- =========================================================
CREATE OR REPLACE FUNCTION after_stmt_func()
RETURNS TRIGGER AS $$
BEGIN
    RAISE NOTICE 'AFTER STATEMENT (Statement-Level) Trigger Fired for operation: %', TG_OP;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_stmt_trigger
AFTER UPDATE OR DELETE ON library
FOR EACH STATEMENT
EXECUTE FUNCTION after_stmt_func();

-- =========================================================
-- üßæ TEST THE TRIGGERS
-- =========================================================
-- UPDATE a record (fires all 4 triggers)
UPDATE library SET allowed_days = 15 WHERE bno = 1;

-- DELETE a record (fires all 4 triggers)
DELETE FROM library WHERE bno = 2;

-- =========================================================
-- üîç VIEW RESULTS
-- =========================================================
SELECT * FROM library;         -- Current library data
SELECT * FROM library_audit;   -- Audit history
```











# mongo1

```javascript
// --------------------------------------------------
// PIZZA DELIVERY SYSTEM ‚Äì MONGODB CRUD OPERATIONS
// --------------------------------------------------

// 1Ô∏è‚É£  CREATE / USE DATABASE
use PizzaDeliverySystem; 
// Creates a new database called 'PizzaDeliverySystem' if it doesn't exist
// or switches to it if it already exists

// --------------------------------------------------
// 2Ô∏è‚É£  CREATE COLLECTIONS & INSERT DOCUMENTS
// --------------------------------------------------

// Insert multiple pizza documents into the 'pizzas' collection
db.pizzas.insertMany([
  { _id: 1, name: "Margherita", size: "Medium", price: 300, ingredients: ["Cheese", "Tomato"], tags: ["Vegetarian", "Classic"] },
  { _id: 2, name: "Pepperoni", size: "Large", price: 450, ingredients: ["Cheese", "Pepperoni"], tags: ["Non-Vegetarian", "Spicy"] },
  { _id: 3, name: "Farmhouse", size: "Medium", price: 400, ingredients: ["Cheese", "Vegetables"], tags: ["Vegetarian", "Loaded"] }
]);
// insertMany ‚Üí Adds multiple documents at once
// _id ‚Üí unique identifier for each pizza
// ingredients ‚Üí array field listing pizza ingredients
// tags ‚Üí array field for categories/labels

// Insert one pizza document
db.pizzas.insertOne({
  _id: 4,
  name: "Devinshire",
  size: "Medium",
  price: 230,
  ingredients: ["Basil", "Tomato"],
  tags: ["Vegetarian", "American"]
});
// insertOne ‚Üí Adds a single document to the collection

// Insert multiple customer documents into 'customers' collection
db.customers.insertMany([
  { _id: 1, name: "Amit", phone: "9001112233", address: "Sector 10, City Center", favorite_pizzas: ["Margherita"] },
  { _id: 2, name: "Sara", phone: "9003445566", address: "Lakeview Apartments", favorite_pizzas: ["Pepperoni"] }
]);
// favorite_pizzas ‚Üí array field storing customer's favorite pizzas

// Insert multiple orders into 'orders' collection
db.orders.insertMany([
  { _id: 1001, customer_id: 1, pizza_ids: [1, 3], total: 700, order_date: ISODate("2025-07-26T18:30:00Z"), status: "Delivered" },
  { _id: 1002, customer_id: 2, pizza_ids: [2], total: 450, order_date: ISODate("2025-07-27T11:00:00Z"), status: "Preparing" }
]);
// pizza_ids ‚Üí array field storing ordered pizza IDs
// order_date ‚Üí ISODate format for date and time

// --------------------------------------------------
// 3Ô∏è‚É£  READ OPERATIONS (QUERY, LOGICAL OPERATORS, SORT, LIMIT, PROJECTION)
// --------------------------------------------------

// View all pizzas with pretty formatting
db.pizzas.find().pretty();
// pretty() ‚Üí formats JSON output for readability

// View all customers
db.customers.find().pretty();

// View all orders
db.orders.find().pretty();

// Find pizzas with price greater than 350
db.pizzas.find({ price: { $gt: 350 } });
// $gt ‚Üí comparison operator: greater than

// Find orders with total greater than or equal to 700
db.orders.find({ total: { $gte: 700 } });
// $gte ‚Üí greater than or equal

// Find Medium pizzas with price > 300 using $and logical operator
db.pizzas.find({
  $and: [
    { size: "Medium" },
    { price: { $gt: 300 } }
  ]
});
// $and ‚Üí all conditions must be true

// Find customers named Amit OR Sara using $or
db.customers.find({
  $or: [
    { name: "Amit" },
    { name: "Sara" }
  ]
});
// $or ‚Üí at least one condition must be true

// Find pizzas with price not greater than 400 using $not
db.pizzas.find({ price: { $not: { $gt: 400 } } });
// $not ‚Üí negates a condition (price ‚â§ 400)

// Find customers where neither condition is true using $nor
db.customers.find({
  $nor: [
    { name: "Amit" },
    { phone: "9003445566" }
  ]
});
// $nor ‚Üí none of the conditions should be true

// Find pizzas with tags either Spicy or Loaded using $in
db.pizzas.find({ tags: { $in: ["Spicy", "Loaded"] } });

// Find pizzas excluding Farmhouse and Pepperoni using $nin
db.pizzas.find({ name: { $nin: ["Farmhouse", "Pepperoni"] } });

// --------------------------------------------------
// SORT, LIMIT, PROJECTION examples
// --------------------------------------------------

// Show pizza names and prices only, sorted by price descending, limit 3
db.pizzas.find({}, { name: 1, price: 1, _id: 0 }).sort({ price: -1 }).limit(3);
// {} ‚Üí no filter, returns all documents
// Projection ‚Üí { name: 1, price: 1, _id: 0 } ‚Üí include name & price, exclude _id
// sort({ price: -1 }) ‚Üí descending
// limit(3) ‚Üí return only 3 documents

// Show all orders sorted by total ascending, limit 5
db.orders.find().sort({ total: 1 }).limit(5);

// Show customer names only, sorted alphabetically
db.customers.find({}, { name: 1, _id: 0 }).sort({ name: 1 });

// Combined example: Medium pizzas, only name & price, sorted by price descending, limit 2
db.pizzas.find({ size: "Medium" }, { name: 1, price: 1, _id: 0 }).sort({ price: -1 }).limit(2);

// --------------------------------------------------
// 4Ô∏è‚É£  UPDATE OPERATIONS
// --------------------------------------------------

// Update single field: change Amit's phone
db.customers.updateOne({ name: "Amit" }, { $set: { phone: "9000000000" } });
// $set ‚Üí updates or adds a field

// Increment numeric field: increase order total by 50
db.orders.updateOne({ _id: 1002 }, { $inc: { total: 50 } });
// $inc ‚Üí increment numeric field by specified value

// Add element to array: add 'BestSeller' tag to Margherita
db.pizzas.updateOne({ name: "Margherita" }, { $push: { tags: "BestSeller" } });
// $push ‚Üí adds element to array

// Add multiple elements to array using $each
db.pizzas.updateOne({ name: "Farmhouse" }, { $push: { tags: { $each: ["Offers", "Recommended"] } } });
// $each ‚Üí adds multiple elements at once

// Add unique element to array using $addToSet
db.pizzas.updateOne({ name: "Pepperoni" }, { $addToSet: { tags: "Classic" } });
// $addToSet ‚Üí adds element only if it doesn't exist

// Rename a field: phone ‚Üí contact
db.customers.updateOne({ name: "Amit" }, { $rename: { phone: "contact" } });
// $rename ‚Üí renames a field

// Multiply numeric field: increase price by 10%
db.pizzas.updateOne({ name: "Pepperoni" }, { $mul: { price: 1.1 } });
// $mul ‚Üí multiply numeric field

// Remove specific field: remove Sara's address
db.customers.updateOne({ name: "Sara" }, { $unset: { address: "" } });
// $unset ‚Üí deletes a field from a document

// --------------------------------------------------
// 5Ô∏è‚É£  SAVE METHOD
// --------------------------------------------------

// Update existing document using save
var pizza = db.pizzas.findOne({ name: "Margherita" });
pizza.price = 320;
db.pizzas.save(pizza);
// save() ‚Üí replaces the document if _id exists; otherwise inserts new

// Insert new document using save
db.pizzas.save({
  _id: 5,
  name: "Veggie Delight",
  size: "Small",
  price: 250,
  ingredients: ["Cheese", "Bell Pepper", "Onion"],
  tags: ["Vegetarian", "Healthy"]
});

// --------------------------------------------------
// 6Ô∏è‚É£  DELETE OPERATIONS
// --------------------------------------------------

// Delete one document: remove Devinshire pizza
db.pizzas.deleteOne({ name: "Devinshire" });

// Delete many documents: remove pizzas with price < 300
db.pizzas.deleteMany({ price: { $lt: 300 } });

// Remove element from array: remove Margherita from Amit's favorite pizzas
db.customers.updateOne({ name: "Amit" }, { $pull: { favorite_pizzas: "Margherita" } });
// $pull ‚Üí removes matching elements from an array

// Remove last element from pizza_ids array in order 1001
db.orders.updateOne({ _id: 1001 }, { $pop: { pizza_ids: 1 } });
// $pop ‚Üí removes first (-1) or last (1) element from array

// --------------------------------------------------
// 7Ô∏è‚É£  BONUS ‚Äì AGGREGATION EXAMPLE
// --------------------------------------------------

// Aggregate orders by customer, count total orders and sum total_amount, sort descending
db.orders.aggregate([
  { $group: { _id: "$customer_id", total_orders: { $sum: 1 }, total_amount: { $sum: "$total" } } },
  { $sort: { total_amount: -1 } }
]);
// $group ‚Üí groups documents by _id (customer_id), calculates aggregates
// $sum ‚Üí sums values or counts documents
// $sort ‚Üí sorts by total_amount descending
```











# mongo 2

```javascript
//----------------------------------------------------------
// PIZZA DELIVERY SYSTEM ‚Äì AGGREGATION & INDEXING
//----------------------------------------------------------

// 1Ô∏è‚É£ USE DATABASE
use PizzaDel2;

//----------------------------------------------------------
// 2Ô∏è‚É£ INSERT SAMPLE DATA
//----------------------------------------------------------
db.pizzas.insertMany([
  { _id: 1, name: "Margherita", size: "Medium", price: 300, tags: ["Vegetarian", "Classic"] },
  { _id: 2, name: "Pepperoni", size: "Large", price: 450, tags: ["Non-Vegetarian", "Spicy"] },
  { _id: 3, name: "Farmhouse", size: "Medium", price: 400, tags: ["Vegetarian", "Loaded"] },
  { _id: 4, name: "Devinshire", size: "Medium", price: 230, tags: ["Vegetarian", "American"] },
  { _id: 5, name: "BBQ Chicken", size: "Large", price: 480, tags: ["Non-Vegetarian", "Spicy"] }
]);

db.customers.insertMany([
  { _id: 1, name: "Amit", favorite_pizzas: ["Margherita"] },
  { _id: 2, name: "Sara", favorite_pizzas: ["Pepperoni"] },
  { _id: 3, name: "Pierre", favorite_pizzas: ["Farmhouse", "BBQ Chicken"] }
]);

db.orders.insertMany([
  { _id: 1001, customer_id: 1, pizza_ids: [1,3], total: 700, status: "Delivered" },
  { _id: 1002, customer_id: 2, pizza_ids: [2], total: 450, status: "Preparing" },
  { _id: 1003, customer_id: 3, pizza_ids: [3,5], total: 880, status: "Delivered" },
  { _id: 1004, customer_id: 1, pizza_ids: [4], total: 230, status: "Cancelled" }
]);

//----------------------------------------------------------
// 3Ô∏è‚É£ AGGREGATION EXAMPLES
//----------------------------------------------------------

// Total sales per customer
db.orders.aggregate([
  { $group: { _id: "$customer_id", totalSpent: { $sum: "$total" } } }
]);

// Count pizzas by size
db.pizzas.aggregate([
  { $group: { _id: "$size", count: { $sum: 1 } } }
]);

// Total revenue per order status
db.orders.aggregate([
  { $group: { _id: "$status", totalRevenue: { $sum: "$total" } } }
]);

// Top 2 most expensive pizzas
db.pizzas.aggregate([
  { $sort: { price: -1 } },
  { $limit: 2 }
]);

// Count vegetarian pizzas
db.pizzas.aggregate([
  { $match: { tags: "Vegetarian" } },
  { $count: "vegetarianPizzas" }
]);

//----------------------------------------------------------
// 4Ô∏è‚É£ INDEXING EXAMPLES
//----------------------------------------------------------

// Text index on name and tags
db.pizzas.createIndex({ name: "text", tags: "text" });
db.pizzas.find({ $text: { $search: "Vegetarian" } }); 

// Unique index on customer name
db.customers.createIndex({ name: 1 }, { unique: true });
db.customers.insertOne({_id :4 , name: "Sara" }); 


// Single field index on pizza price
db.pizzas.createIndex({ price: 1 });
db.pizzas.find({ price: 400 });
db.pizzas.find().sort({ price: 1 });


// Compound index on pizza size and price
db.pizzas.createIndex({ size: 1, price: -1 });
db.pizzas.find({ size: "Medium" }).sort({ price: -1 });


// Check indexes
db.pizzas.getIndexes();
db.customers.getIndexes();
db.orders.getIndexes();
```











# mongo 3

```javascript
//----------------------------------------------------------
// MAPREDUCE EXAMPLE ‚Äì BILL COLLECTION
//----------------------------------------------------------

// 1Ô∏è‚É£ Use Database
use bill;

// 2Ô∏è‚É£ Insert Sample Data (if not already present)
db.pay.drop(); // Clear existing data

db.pay.insertMany([
  { Cust_ID: "A123", Product: "Milk", Amount: 40, Status: "P" },
  { Cust_ID: "A123", Product: "Parle_G", Amount: 50, Status: "NP" },
  { Cust_ID: "A123", Product: "Lays Chips", Amount: 40, Status: "P" },
  { Cust_ID: "B123", Product: "Mentos", Amount: 10, Status: "P" },
  { Cust_ID: "B123", Product: "Maggie", Amount: 60, Status: "NP" }
]);

print("‚úÖ Sample Data:");
db.pay.find().pretty();

//----------------------------------------------------------
// 3Ô∏è‚É£ MAPREDUCE ‚Äì Calculate Total Pending Amount per Customer
//----------------------------------------------------------

// Map Function: emits customer ID and amount only for unpaid items
var mapFunc = function() {
    if (this.Status === "NP") {        // Only consider Not Paid items
        emit(this.Cust_ID, this.Amount);
    }
};

// Reduce Function: sums all amounts for each customer
var reduceFunc = function(keyCustID, valueAmounts) {
    return Array.sum(valueAmounts);
};

// Optional Finalize Function: add descriptive info
var finalizeFunc = function(keyCustID, reducedVal) {
    return { totalPending: reducedVal, note: "Pending payment" };
};

// Execute MapReduce
db.pay.mapReduce(
    mapFunc,             
    reduceFunc,          
    {
        out: "PendingAmounts",  // Output collection
        finalize: finalizeFunc  // Optional finalize for better output
    }
);

print("üéØ Total Pending Amount per Customer:");
db.PendingAmounts.find().pretty();

//----------------------------------------------------------
// 4Ô∏è‚É£ MAPREDUCE ‚Äì Calculate Total Amount (All Payments) per Customer
//----------------------------------------------------------

// Map Function: emits customer ID and amount for all items
var mapFuncAll = function() {
    emit(this.Cust_ID, this.Amount);
};

// Reduce Function: sums all amounts for each customer
var reduceFuncAll = function(keyCustID, valueAmounts) {
    return Array.sum(valueAmounts);
};

// Execute MapReduce for all payments
db.pay.mapReduce(
    mapFuncAll,
    reduceFuncAll,
    { out: "TotalAmounts" }  // Output collection
);

print("üéØ Total Amount per Customer (All Payments):");
db.TotalAmounts.find().pretty();
```











# sql 3

```sql
CREATE DATABASE IF NOT EXISTS office_db;
USE office_db;
CREATE TABLE IF NOT EXISTS dept (did INT AUTO_INCREMENT PRIMARY KEY, dname VARCHAR(30), city VARCHAR(20));
CREATE TABLE IF NOT EXISTS emp (eid INT AUTO_INCREMENT PRIMARY KEY, ename VARCHAR(30), salary INT, gender CHAR(1), did INT, FOREIGN KEY (did) REFERENCES dept(did));
INSERT INTO dept (dname, city) VALUES ('HR','Pune'),('IT','Mumbai'),('Admin','Delhi'),('Finance','Nashik');
INSERT INTO emp (ename, salary, gender, did) VALUES ('Harshada',55000,'F',2),('Sarvesh',48000,'M',2),('Riya',40000,'F',1),('Om',60000,'M',3),('Tanu',35000,'F',NULL);
SELECT * FROM dept;
SELECT * FROM emp;
SELECT e.ename, d.dname, d.city FROM emp e INNER JOIN dept d ON e.did=d.did;
SELECT e.ename, d.dname FROM emp e LEFT JOIN dept d ON e.did=d.did;
SELECT e.ename, d.dname FROM emp e RIGHT JOIN dept d ON e.did=d.did;
SELECT e.ename, d.dname FROM emp e CROSS JOIN dept d;
SELECT ename, salary FROM emp WHERE salary>(SELECT AVG(salary) FROM emp);
SELECT ename, salary FROM emp WHERE salary=(SELECT MAX(salary) FROM emp);
SELECT dname FROM dept WHERE did=(SELECT did FROM emp GROUP BY did ORDER BY COUNT(*) DESC LIMIT 1);
SELECT e.ename, e.salary FROM emp e WHERE e.salary>(SELECT AVG(salary) FROM emp WHERE did=e.did);
CREATE VIEW emp_view AS SELECT e.ename, e.salary, d.dname, d.city FROM emp e LEFT JOIN dept d ON e.did=d.did;
SELECT * FROM emp_view;
UPDATE emp SET salary=salary+5000 WHERE ename='Riya';
SELECT * FROM emp_view;
DROP VIEW emp_view;
```











# sql2

```sql
SHOW DATABASES;
CREATE DATABASE employee;
USE employee;
CREATE TABLE emp_details (emp_no INT AUTO_INCREMENT PRIMARY KEY, emp_name VARCHAR(30), emp_gender CHAR(1), emp_sal INT NOT NULL, emp_dept VARCHAR(20));
DESC emp_details;
INSERT INTO emp_details (emp_name, emp_gender, emp_sal, emp_dept) VALUES ('Ram','M',300000,'Designing'),('Soham','M',300000,'Designing'),('Mohan','M',250000,'Management'),('Om','M',400000,'Coding');
SELECT * FROM emp_details;
CREATE TABLE emp_info AS SELECT emp_no, emp_name, emp_gender FROM emp_details;
SELECT * FROM emp_info;
TRUNCATE TABLE emp_info;
DROP TABLE emp_info;
CREATE VIEW emp_view1 AS SELECT * FROM emp_details;
CREATE VIEW emp_view2 AS SELECT * FROM emp_details WHERE emp_dept='Designing';
SELECT * FROM emp_view1;
SELECT * FROM emp_view2;
UPDATE emp_details SET emp_dept='Coding' WHERE emp_name='Mohan';
DROP VIEW emp_view1;
DROP VIEW emp_view2;
CREATE INDEX emp_ind ON emp_details(emp_no, emp_name);
SHOW INDEX FROM emp_details;
SELECT * FROM emp_details;
SELECT emp_name, emp_dept FROM emp_details WHERE emp_dept='Coding';
SELECT emp_name, emp_sal FROM emp_details WHERE emp_sal>300000;
UPDATE emp_details SET emp_sal=emp_sal*1.10 WHERE emp_dept='Designing';
DELETE FROM emp_details WHERE emp_name='Om';
SELECT * FROM emp_details ORDER BY emp_sal DESC;
SELECT emp_dept, COUNT(*) AS total_emp FROM emp_details GROUP BY emp_dept;
SELECT emp_dept, AVG(emp_sal) AS avg_salary FROM emp_details GROUP BY emp_dept;
SELECT emp_name, emp_sal FROM emp_details ORDER BY emp_sal DESC LIMIT 1;
ALTER TABLE emp_details ADD emp_city VARCHAR(20);
UPDATE emp_details SET emp_city='Pune' WHERE emp_dept='Coding';
UPDATE emp_details SET emp_city='Mumbai' WHERE emp_dept='Designing';
UPDATE emp_details SET emp_city='Delhi' WHERE emp_dept='Management';
SELECT emp_name, emp_dept, emp_city FROM emp_details;
```











# plsql 6

6. Database Trigger (All Types: Row level and Statement level triggers, Before and After Triggers).

```sql
-- 1Ô∏è‚É£ Drop Tables if Exist
DROP TABLE IF EXISTS Library_Audit;
DROP TABLE IF EXISTS Library;


-- 2Ô∏è‚É£ Create Library Table
CREATE TABLE Library (
    book_id SERIAL PRIMARY KEY,
    book_name VARCHAR(100),
    author VARCHAR(50),
    issued_to INT,
    status CHAR(1) DEFAULT 'I'  -- I = Issued, R = Returned
);


-- 3Ô∏è‚É£ Create Audit Table
CREATE TABLE Library_Audit (
    audit_id SERIAL PRIMARY KEY,
    book_id INT,
    book_name VARCHAR(100),
    author VARCHAR(50),
    issued_to INT,
    status CHAR(1),
    action_type VARCHAR(10),      -- 'INSERT', 'UPDATE', 'DELETE'
    action_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


-- 4Ô∏è‚É£ Create Trigger Function
CREATE OR REPLACE FUNCTION library_audit_trigger()
RETURNS TRIGGER AS $
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO Library_Audit(book_id, book_name, author, issued_to, status, action_type)
        VALUES (NEW.book_id, NEW.book_name, NEW.author, NEW.issued_to, NEW.status, 'INSERT');
        RETURN NEW;


    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO Library_Audit(book_id, book_name, author, issued_to, status, action_type)
        VALUES (OLD.book_id, OLD.book_name, OLD.author, OLD.issued_to, OLD.status, 'UPDATE');
        RETURN NEW;


    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO Library_Audit(book_id, book_name, author, issued_to, status, action_type)
        VALUES (OLD.book_id, OLD.book_name, OLD.author, OLD.issued_to, OLD.status, 'DELETE');
        RETURN OLD;
    END IF;
END;
$ LANGUAGE plpgsql;


-- 5Ô∏è‚É£ Create Triggers on Library Table


-- BEFORE INSERT Trigger (Row-Level)
CREATE TRIGGER trg_library_insert
AFTER INSERT ON Library
FOR EACH ROW
EXECUTE FUNCTION library_audit_trigger();


-- BEFORE UPDATE Trigger (Row-Level)
CREATE TRIGGER trg_library_update
BEFORE UPDATE ON Library
FOR EACH ROW
EXECUTE FUNCTION library_audit_trigger();


-- BEFORE DELETE Trigger (Row-Level)
CREATE TRIGGER trg_library_delete
BEFORE DELETE ON Library
FOR EACH ROW
EXECUTE FUNCTION library_audit_trigger();


-- 6Ô∏è‚É£ Insert Sample Data
INSERT INTO Library(book_name, author, issued_to, status) VALUES
('Database Systems', 'Alice', 101, 'I'),
('Algorithms', 'Bob', 102, 'I'),
('Operating Systems', 'Charlie', 103, 'I');


-- 7Ô∏è‚É£ Test Triggers


-- Update a Book
UPDATE Library
SET status = 'R', issued_to = NULL
WHERE book_id = 1;


-- Delete a Book
DELETE FROM Library
WHERE book_id = 2;


-- Insert a New Book
INSERT INTO Library(book_name, author, issued_to, status)
VALUES ('Data Science', 'David', 104, 'I');


-- 8Ô∏è‚É£ Verify Audit Table
SELECT * FROM Library_Audit;


-- 9Ô∏è‚É£ Verify Library Table
SELECT * FROM Library;
```

---

**Additional plsql6 code:**

```sql
-- üßπ Step 1: Drop tables if they exist
DROP TABLE IF EXISTS n_rollcall;
DROP TABLE IF EXISTS o_rollcall;

-- üèó Step 2: Create tables
CREATE TABLE n_rollcall (
    roll INT PRIMARY KEY,
    name VARCHAR(20),
    class VARCHAR(10)
);

CREATE TABLE o_rollcall (
    roll INT PRIMARY KEY,
    name VARCHAR(20),
    class VARCHAR(10)
);

-- üßæ Step 3: Insert sample data
INSERT INTO n_rollcall VALUES 
(1, 'Arushi', 'SE'),
(2, 'Pranali', 'SE');

INSERT INTO o_rollcall VALUES 
(2, 'Pranali', 'SE'),
(3, 'Harshada', 'TE'),
(4, 'Aditi', 'BE');

-- ‚öô Step 4: Create procedure using explicit cursor
CREATE OR REPLACE PROCEDURE merge_roll_data()
LANGUAGE plpgsql
AS $
DECLARE
    v_roll INT;
    v_name VARCHAR(20);
    v_class VARCHAR(10);
    v_count INT;

    -- Explicit cursor to iterate through old rollcall table
    c1 CURSOR FOR SELECT roll, name, class FROM o_rollcall;
BEGIN
    OPEN c1;
    LOOP
        FETCH c1 INTO v_roll, v_name, v_class;
        EXIT WHEN NOT FOUND;

        -- Check if this roll already exists in new_rollcall
        SELECT COUNT(*) INTO v_count FROM n_rollcall WHERE roll = v_roll;

        IF v_count = 0 THEN
            INSERT INTO n_rollcall (roll, name, class) VALUES (v_roll, v_name, v_class);
            RAISE NOTICE '‚úÖ Inserted: Roll=% | Name=% | Class=%', v_roll, v_name, v_class;
        ELSE
            RAISE NOTICE '‚è© Skipped duplicate: Roll=% already exists', v_roll;
        END IF;
    END LOOP;

    CLOSE c1;
    RAISE NOTICE 'üéØ Merge Completed Successfully!';
END;
$;

-- ‚ñ∂ Step 5: Execute the procedure
CALL merge_roll_data();

-- üìä Step 6: Verify data
SELECT * FROM n_rollcall ORDER BY roll;
```

---

**Alternative plsql6 implementation:**

```sql
create or replace procedure merge_rollcalls()
language plpgsql
as $
declare
	merge_cur refcursor;
	rec record;
	r record;
	v_exists int;
begin
	for r in select * from N_RollCall loop
		select count(*) into v_exists from O_RollCall where roll_no= r.roll_no;
		if v_exists= 0 then
			open merge_cur for select * from N_RollCall where roll_no= r.roll_no;
			fetch merge_cur into rec;
			insert into O_RollCall values (rec.roll_no, rec.name);
			raise notice 'inserted roll no: %, name: %', rec.roll_no, rec.name;
			close merge_cur;
		else
			raise notice 'skipped (already exists) roll no: %, name: %', r.roll_no, r.name; 
		end if;
	end loop;
exception
	when others then 
		raise notice 'unexpected error!';
end;
$;
call merge_rollcalls();
```











# plsql 4

```sql
DROP TABLE IF EXISTS fine;
DROP TABLE IF EXISTS borrower;

CREATE TABLE borrower(
    roll_no INT,
    name TEXT,
    date_of_issue DATE,
    name_of_book TEXT,
    status CHAR(1)
);

CREATE TABLE fine(
    roll_no INT,
    return_date DATE,
    amount NUMERIC(10,2)
);

INSERT INTO borrower VALUES
(101, 'Alice', '2025-10-01', 'Mathematics', 'I'),
(102, 'Bob', '2025-09-15', 'Physics', 'I'),
(103, 'Charlie', '2025-09-20', 'Chemistry', 'I'),
(104, 'David', '2025-10-05', 'Biology', 'I'),
(105, 'Eve', '2025-09-25', 'English', 'I');

DO $
DECLARE
    v_roll_no INT := 103;
    v_book TEXT := 'Chemistry';
    v_issue_date DATE;
    v_days INT;
    v_fine NUMERIC := 0;
BEGIN
    SELECT date_of_issue INTO v_issue_date
    FROM borrower
    WHERE roll_no = v_roll_no AND name_of_book = v_book;

    IF NOT FOUND THEN
        RAISE NOTICE 'No record found for roll_no % and book %', v_roll_no, v_book;
        RETURN;
    END IF;

    v_days := CURRENT_DATE - v_issue_date;
    RAISE NOTICE 'Days since issue: %', v_days;

    IF v_days > 30 THEN
        v_fine := (30 * 5) + (v_days - 30) * 50;
    ELSIF v_days >= 15 THEN
        v_fine := v_days * 5;
    ELSE
        v_fine := 0;
    END IF;

    RAISE NOTICE 'Calculated fine: Rs.%', v_fine;

    UPDATE borrower
    SET status = 'R'
    WHERE roll_no = v_roll_no AND name_of_book = v_book;

    IF v_fine > 0 THEN
        INSERT INTO fine VALUES (v_roll_no, CURRENT_DATE, v_fine);
    END IF;

    RAISE NOTICE 'Return and fine process completed successfully!';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Unexpected error occurred!';
END;
$ LANGUAGE plpgsql;

SELECT * FROM borrower;
SELECT * FROM fine;
```











# plsql 5

```sql
DROP TABLE IF EXISTS result;
DROP TABLE IF EXISTS stud_marks;

CREATE TABLE stud_marks (
    name VARCHAR(20),
    total_marks INT
);

CREATE TABLE result (
    roll_no SERIAL PRIMARY KEY,
    name VARCHAR(20),
    class VARCHAR(30)
);

INSERT INTO stud_marks VALUES
('Suresh', 995),
('Harish', 865),
('Samarth', 920),
('Mohan', 1000),
('Soham', 745);

INSERT INTO result (name) VALUES
('Suresh'),
('Harish'),
('Samarth'),
('Mohan'),
('Soham');

CREATE OR REPLACE PROCEDURE proc_grade(p_roll INT)
LANGUAGE plpgsql
AS $
DECLARE
    v_name VARCHAR(20);
    v_marks INT;
    v_class VARCHAR(25);
BEGIN
    SELECT name INTO v_name FROM result WHERE roll_no = p_roll;
    SELECT total_marks INTO v_marks FROM stud_marks WHERE name = v_name;

    IF v_marks BETWEEN 990 AND 1500 THEN
        v_class := 'Distinction';
    ELSIF v_marks BETWEEN 900 AND 989 THEN
        v_class := 'First Class';
    ELSIF v_marks BETWEEN 825 AND 899 THEN
        v_class := 'Higher Second Class';
    ELSE
        v_class := 'Fail';
    END IF;

    UPDATE result
    SET class = v_class
    WHERE roll_no = p_roll;

    RAISE NOTICE 'Roll No: %, Name: %, Marks: %, Class: %', p_roll, v_name, v_marks, v_class;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE NOTICE 'No record found for Roll No: %', p_roll;
END;
$;

CREATE OR REPLACE FUNCTION func_grade(p_roll INT)
RETURNS VARCHAR
LANGUAGE plpgsql
AS $
DECLARE
    v_class VARCHAR(25);
BEGIN
    CALL proc_grade(p_roll);
    SELECT class INTO v_class FROM result WHERE roll_no = p_roll;
    RETURN v_class;
END;
$;

SELECT func_grade(1);
SELECT func_grade(2);
SELECT func_grade(3);
SELECT func_grade(4);
SELECT func_grade(5);

SELECT * FROM result;
```











# plsql 7

```sql
DROP TABLE IF EXISTS library_audit;
DROP TABLE IF EXISTS library;

CREATE TABLE library (
    bno INT PRIMARY KEY,
    bname VARCHAR(40),
    author VARCHAR(20),
    allowed_days INT
);

CREATE TABLE library_audit (
    audit_id SERIAL PRIMARY KEY,
    bno INT,
    old_allowed_days INT,
    new_allowed_days INT,
    action VARCHAR(10),
    action_time TIMESTAMP DEFAULT NOW()
);

INSERT INTO library VALUES (1,'Database Systems','Tom',10);
INSERT INTO library VALUES (2,'System Programming','John',20);
INSERT INTO library VALUES (3,'Computer Networks','Sara',18);
INSERT INTO library VALUES (4,'Agile Project Management','Ken',24);
INSERT INTO library VALUES (5,'Python for Data Analysis','Wes',12);

CREATE OR REPLACE FUNCTION library_audit_func()
RETURNS TRIGGER AS $
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO library_audit(bno, old_allowed_days, new_allowed_days, action)
        VALUES (OLD.bno, OLD.allowed_days, NEW.allowed_days, 'UPDATE');
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO library_audit(bno, old_allowed_days, new_allowed_days, action)
        VALUES (OLD.bno, OLD.allowed_days, NULL, 'DELETE');
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER library_audit_trigger
AFTER UPDATE OR DELETE ON library
FOR EACH ROW
EXECUTE FUNCTION library_audit_func();

UPDATE library SET allowed_days = 15 WHERE bno = 1;
UPDATE library SET allowed_days = 25 WHERE bno = 2;
DELETE FROM library WHERE bno = 3;

SELECT * FROM library;
SELECT * FROM library_audit ORDER BY action_time;